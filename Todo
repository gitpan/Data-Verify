todo
{
	Implement fails as Exception (Error Module) using 'describe' to give versatile information.

	my @fails;

	while( @tests )
	{
		try
		{
			verify( $_ );
		}
		catch Data::Verify::Exception
		{
			push @fails, $exception;
		}
	}

	print $_->totext foreach @fails;
}
done
{
	use Error qw(:try);

	use Data::Verify;

	try
	{
		my $test = Data::Verify->new( %$href_args );

			# what does this type verify mean

		println $test->info;

			# returns an array of test-information

		println join "\n", $test->describe;

			# start our test-program and throw exception when there is trouble

		$test->verify;
	}
	catch Data::Verify::Exception with
	{
	    my $e = shift;

	    printfln "\n%s:", $e->text;

	    println "Error ==> Expected that ".$_->text foreach @{ $e->object->fails };
	};
}

todo
{
	Update the documentation for the new Exception/oo-perl interface.
}

todo
{
	- Bouncer has to use the new interface.

	- Bouncer should throw Exceptions.

	- Bouncer::Test should accept test via given subs:

		Bouncer::Test->new( field => 'x', test => sub { $_ > 1 } );

	- Add Bouncer::Group, where different bouncers jointly make decisions.
}

todo
{
	Write a Class::Maker extension for verifying if the attributes match its types (This can be done
	with a flexible (reflex-inspecting) bouncer).
}

todo
{
	- Review Bouncer interface. Couldn't we just say that 'an object' is a value, and we perform
	a couple of Data::Verify::Test's on it.

	This would make a Bouncer identical to 'Data::Verify::Test'.

	$registry->{user_bouncer} = new Data::Verify::Type( desc => 'a true value', pass => { bool => 1 } );

	Example:

		my $test = Data::Verify->new( value => $this, type => 'user_bouncer' );

		$test->verify;
}
done
{
	Not a solution ! Because our current Data::Verify::Test doesn't now which method of $this to call
	against.

	This functionalitiy should be given by Bouncer.
}

todo
{
	- Introduce parameterised Tests, like "string(80)" would test type "string" with parameter "80".
}
done
{
	works.
}

todo
{
	cleanup the Interfaces. ::Verify::Test and ::Verify::Type should have identical interfaces !
}

info
{
	COMPLETE REWRITE. COMPLETE REWRITE. COMPLETE REWRITE. COMPLETE REWRITE. COMPLETE REWRITE.
	#########################################################################################

						Todo is obsolete or already implemented.

	#########################################################################################
	COMPLETE REWRITE. COMPLETE REWRITE. COMPLETE REWRITE. COMPLETE REWRITE. COMPLETE REWRITE.
}

todo
{
	- Implement decision table for bouncer-like (bouncer is far too simple for the new possibilities)
	scenarios.
}

todo
{
	Create warnings/exceptions with correct line-numbering.
}
done
{
	implemented via caller. cave: was_file and was_line is used for Failure::Type exception.
}

todo
{
	clean the exception/Error handling. Somehow ->line and ->file don't function correctly.
}
done

todo
{
	- Implement Mysql Column types.
	- Create a namespace for these ?!
	- Bring some hierachy into the namespaces, ie. "basic", "databases", "time and dates",

	ie. MYSQL::TIME vs (normal) TIME
}

todo
{
	verify/typ again multiple types at once !
	
	verify( $string, VARCHAR(80), EMAIL )
}
comment
{
    isnt that default ?
}
done
{
	yes it is
}

todo
{
    add filters.
}
done
{
	See Filter::
}

todo
{
	overify() / Data::Verify::Guard should report which member failed
}

